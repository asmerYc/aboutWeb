//第一章：正则表达式字符匹配攻略
//1.两种模糊匹配
// 如果正则表达式只有精准匹配是没有什么意义的，比如/hello/也只能匹配Hello中这个字符串var 

var regex =/hello/

console.log(regex.test('hello'))


//正则表达式之所以强大正是因为其能实现模糊的搜索
// 而模糊匹配 有两个方向上的模糊，横向模糊和纵向模糊

//1.1横向模糊匹配：横向模糊匹配是指，一个正则可匹配的字符串长度不是固定的，可以是多种情况的
// 其实现的方式是使用量词，譬如：{m,n}表示连续出现的最少m次，最多n次
// 比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符串是‘a’,接下来第二个到第五个都是'b',最后是字符串c，测试如下；
var regex1 = /ab{2,5}c/g;
var string = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'
console.log(string.match(regex1))

// 注意上述案例中用的正则是/ab{2,5}c/g,后边多了一个g他是正则的一个修饰符，表示全局匹配，即在目标字符串中
// 按照顺序找到满足匹配模式的所有子串，强调的是‘所有’，而不是只有第一个，g是单词‘global’的首字母


//1.2 纵向模糊匹配:一个正则匹配的字符串，具体到某一位字符的时候，他可以不是某一个确定的字符，可以是多种可能

// 其实现的方式是使用字符组，譬如：[abc],表示该字符 可以是字符串a,b,c中的某一个
// 比如/a[123]b/ 可以匹配如下三种字符串：‘a1b,a2b,a3b’:测试如下：
var regex3 = /a[123]b/g;
var string3 = 'a0b a1b a2b a3b a4b';
console.log(string3.match(regex3))

// 只要掌握横向和纵向匹配，就能解决正则的大部分内容


// 2.字符组：需要强调的是，虽然叫做字符组（字符类）但是只是其中的一个字符例如：[abc]表示匹配一个字符串
// 表示'a','b','c'之一
// 2.1范围表示法
// 如果字符组里面的字符特别多的话，怎办，我们可以使用范围表示法
// 比如[123456abcdefGHIJKLM] 可以写成[1-6a-fG-M],用连接符号-来省略和简写
// 因为连字符的特殊用途，那么要匹配‘a’、'-'、‘z’该怎么做呢  

// 不能写成[a-z],因为这个表示小写字符中的任何一个
// 可以写成[-az],[az-],[a\-z] 要么前后写  要么转义，总之，不让引擎认定是范围表示法就行

// 2.2排除字符组
// 纵向模糊匹配的时候有一种情形，某一字符可以是任何形式，但是就是不能是‘a’,'b','c'
// 此时就是排除字符组，例如[^abc]，表示是一个除‘a’,'b','c'之外的任意一个字符，字符组的第一位放^(脱字符)表示求反的概念
// 当然也有相应的范围表示法

// 2.3常见的简写形式

// 有了字符组的概念后，一些常见的符号我们也就理解了，因为他们都是系统自带的简写形式
// \d就是[0-9].表示是一ß数字，记忆方式：其英文是digit(数字)
// \D就是[^0-9].表示除数字外的任意字符
// \w就是[0-9a-zA-Z_].表示数字字母和下划线，记忆方式：w是word的简写，也称单词字符
// \W就是[^0-9a-zA-Z_].非单词字符
// \s 是[\t\v\n\r\f]. 表示空白符，包括空格，水平制表符，垂直制表符，换行符，回车符，换页符，
// 记忆方式：s是space character的首字母
// \S是[^\t\v\n\r\f] 表示法非空白符
// . 就是[^\n\r\u2028\u2029] 通配符。表示几乎任意字符，换行符，回车符，行分隔符除外和段分隔符除外

// 如果要匹配任意字符怎么办？ 可以使用 [\d\D] [\w\W] [\s\S] 和[^]中的任何一个


// 3.量词
