/*
 * @Author: your name
 * @Date: 2020-12-21 10:21:27
 * @LastEditTime: 2020-12-25 15:05:48
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /aboutWeb/learn-regex/test001.js
 */
//第一章：正则表达式字符匹配攻略
//1.两种模糊匹配
// 如果正则表达式只有精准匹配是没有什么意义的，比如/hello/也只能匹配Hello中这个字符串var 

var regex =/hello/

console.log(regex.test('hello'))


//正则表达式之所以强大正是因为其能实现模糊的搜索
// 而模糊匹配 有两个方向上的模糊，横向模糊和纵向模糊

//1.1横向模糊匹配：横向模糊匹配是指，一个正则可匹配的字符串长度不是固定的，可以是多种情况的
// 其实现的方式是使用量词，譬如：{m,n}表示连续出现的最少m次，最多n次
// 比如/ab{2,5}c/表示匹配这样一个字符串：第一个字符串是‘a’,接下来第二个到第五个都是'b',最后是字符串c，测试如下；
var regex1 = /ab{2,5}c/g;
var string = 'abc abbc abbbc abbbbc abbbbbc abbbbbbc'
console.log(string.match(regex1))

// 注意上述案例中用的正则是/ab{2,5}c/g,后边多了一个g他是正则的一个修饰符，表示全局匹配，即在目标字符串中
// 按照顺序找到满足匹配模式的所有子串，强调的是‘所有’，而不是只有第一个，g是单词‘global’的首字母


//1.2 纵向模糊匹配:一个正则匹配的字符串，具体到某一位字符的时候，他可以不是某一个确定的字符，可以是多种可能

// 其实现的方式是使用字符组，譬如：[abc],表示该字符 可以是字符串a,b,c中的某一个
// 比如/a[123]b/ 可以匹配如下三种字符串：‘a1b,a2b,a3b’:测试如下：
var regex3 = /a[123]b/g;
var string3 = 'a0b a1b a2b a3b a4b';
console.log(string3.match(regex3))

// 只要掌握横向和纵向匹配，就能解决正则的大部分内容


// 2.字符组：需要强调的是，虽然叫做字符组（字符类）但是只是其中的一个字符例如：[abc]表示匹配一个字符串
// 表示'a','b','c'之一
// 2.1范围表示法
// 如果字符组里面的字符特别多的话，怎办，我们可以使用范围表示法
// 比如[123456abcdefGHIJKLM] 可以写成[1-6a-fG-M],用连接符号-来省略和简写
// 因为连字符的特殊用途，那么要匹配‘a’、'-'、‘z’该怎么做呢  

// 不能写成[a-z],因为这个表示小写字符中的任何一个
// 可以写成[-az],[az-],[a\-z] 要么前后写  要么转义，总之，不让引擎认定是范围表示法就行

// 2.2排除字符组
// 纵向模糊匹配的时候有一种情形，某一字符可以是任何形式，但是就是不能是‘a’,'b','c'
// 此时就是排除字符组，例如[^abc]，表示是一个除‘a’,'b','c'之外的任意一个字符，字符组的第一位放^(脱字符)表示求反的概念
// 当然也有相应的范围表示法

// 2.3常见的简写形式

// 有了字符组的概念后，一些常见的符号我们也就理解了，因为他们都是系统自带的简写形式
// \d就是[0-9].表示是一ß数字，记忆方式：其英文是digit(数字)
// \D就是[^0-9].表示除数字外的任意字符
// \w就是[0-9a-zA-Z_].表示数字字母和下划线，记忆方式：w是word的简写，也称单词字符
// \W就是[^0-9a-zA-Z_].非单词字符
// \s 是[\t\v\n\r\f]. 表示空白符，包括空格，水平制表符，垂直制表符，换行符，回车符，换页符，
// 记忆方式：s是space character的首字母
// \S是[^\t\v\n\r\f] 表示法非空白符
// . 就是[^\n\r\u2028\u2029] 通配符。表示几乎任意字符，换行符，回车符，行分隔符除外和段分隔符除外

// 如果要匹配任意字符怎么办？ 可以使用 [\d\D] [\w\W] [\s\S] 和[^]中的任何一个


// 3.量词:量词也称重复
// 1.3.1 简写形式
// {m,}:表示至少出现m次
// {m}:等价于{m,m},表示出现了m次
// ?:等价于{0,1},表示出现或者不出现,记忆方式:问号的意思表示,有吗?
// +:等价于{1,},表示至少出现一次,记忆方式:加号是追加的意思,得先有一个才考虑追加
// *:等价于{0,},表示出现任意次

// 1.3.2 贪婪匹配与惰性匹配

var regex4 = /\d{2,5}/g;
var string4 = "123 1234 12345 123456";
console.log(string4.match(regex4))

// 其中正则/\d{2,5}/ 表示数字连续出现2-5次,会匹配2-5位连续数字
// 但是有时候 贪婪不是一件好事,惰性匹配就是尽可能少的匹配

var regex5 = /\d{2,5}?/g;
var string5 = "123 1234 12345 123456";
console.log(string5.match(regex5));

// 上述的例子 虽然2-5次都行,但是两个就够了 就不往下尝试了

// 通过在量词后边加个问号就能实现惰性匹配
// 惰性量词
// {m,n}?  m次或者n次
// {m,}?   m次或者多次
// ??       
// +?
// *

//1.4 多选分支
// 一个模式可以实现横向和纵向模糊匹配,而多选分支可以支持多个子模式 任选其一
// 具体形式如下:(p1|p2|p3),其中p1,p2,p3是子模式,用|(管道符)分割,表示其中任何之一
// 例如要匹配字符串good和nice 可以使用/good|nice/

var regex6 = /good|nice/g;
var string6 = "good idea,nice try";
console.log(string6.match(regex6));

//但是有个事实我们应该注意,比如:我用/good|goodbye/g,去匹配'goodbye'字符串时,结果是good;

var regex7 = /good|goodbye/g;
var string7 = 'goodbye';
console.log(string7.match(regex7));

var regex8 = /goodbye|good/g;
var string8 = 'goodbye';
console.log(string8.match(regex8));
// 分支结构也是惰性的,即当前面的匹配上了 后边的就不会再尝试了

// 1.5 案例分析:匹配字符,无非就是字符组,量词和每个分支结构的组合使用罢了

// 1.5.1:匹配16进制颜色值
// 要求匹配:
// #ffbbad
// #Fc01DF
// #FFF
// #ffE
// 分析:表示一个16进制字符,可以使用字符组[0-9a-fA-F],其中字符可以出现3或者6次,需要使用两次和分支结构,使用分支结构需要注意顺序
var regex9 = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g
var string9 = "#ffbbad #Fc01DF #FFF #ffE";
console.log(string9.match(regex9))

//1.5.2 匹配时间
// 以24小时为例
// 要求匹配: 23:59   02:07
// 分析: 共4位数字,第一位数字可以为[0-2] 当第1位为'2'时候.第2位可以为[0-3],其他情况第2位为[0-9],第三位是[0-5],第四位是[0-9];

// 正则如下

var regex10 = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;
console.log(regex10.test("23:59"));
console.log(regex10.test("02:07"));

//1.5.3 匹配日期
// 比如 yyyy-mm-dd格式为例
// 要求匹配:2017-06-10
// 分析:年份:[0-9]{4}  月份:(0[1-9]|1[0-2]) 日,最多31天 可用(0[1-9]|1[0-9]|2[0-9]|3[01]);
var regex11 = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[01])$/g
console.log(regex11.test("2017-06-20"))

//1.5.4 window操作系统文件路径

// 要求匹配
// F:\study\javascript\regex\regular expression.pdf
// F:\study\javascript\regex\
// F:\study\javascript
// F:\

